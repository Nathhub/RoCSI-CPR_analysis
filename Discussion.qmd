# Discussion â€” Comparing CPR and eDNA: Dimensions of Diversity

The **Continuous Plankton Recorder (CPR)** and the **RoCSI eDNA metabarcoding** represent fundamentally different ways of observing plankton communities. Rather than asking whether these approaches agree or disagree, a more informative question is at what ecological and taxonomic scales they convergeâ€”and where their comparability breaks down.

```{r, echo=FALSE, message=FALSE, warning=FALSE}
library(phyloseq)
library(ggVennDiagram)

ps_18s <- readRDS("data/ps_18s.rds")
ps_coi <- readRDS("data/ps_coi.rds")
ps_cpr <- readRDS("data/ps_cpr.rds")

get_phyla <- function(ps) {
  tt <- tax_table(ps)

  # pull the Phylum column (as character), drop NA/blank/"NA"
  ph <- as.character(tt[, "Phylum"])
  ph <- ph[!is.na(ph) & ph != "" & ph != "NA"]

  sort(unique(ph))
}

phyla_sets <- list(
  `18S` = get_phyla(ps_18s),
  `COI` = get_phyla(ps_coi),
  `CPR` = get_phyla(ps_cpr)
)

# quick counts
sapply(phyla_sets, length)

```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Venn diagram
ggVennDiagram(phyla_sets, label_alpha = 0) +
  ggplot2::labs(title = "Shared phyla across datasets")

```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
library(dplyr)
library(tibble)
library(tidyr)
library(knitr)

shared_all <- Reduce(intersect, phyla_sets)
only_18s   <- setdiff(phyla_sets$`18S`, union(phyla_sets$`COI`, phyla_sets$`CPR`))
only_coi   <- setdiff(phyla_sets$`COI`, union(phyla_sets$`18S`, phyla_sets$`CPR`))
only_cpr   <- setdiff(phyla_sets$`CPR`, union(phyla_sets$`18S`, phyla_sets$`COI`))

phyla_out <- tibble(
  Category = c("Shared by all", "Only 18S", "Only COI", "Only CPR"),
  `# Phyla` = c(length(shared_all), length(only_18s), length(only_coi), length(only_cpr)),
  Phyla = c(
    paste(sort(shared_all), collapse = ", "),
    paste(sort(only_18s), collapse = ", "),
    paste(sort(only_coi), collapse = ", "),
    paste(sort(only_cpr), collapse = ", ")
  )
)

knitr::kable(phyla_out, align = c("l", "r", "l"))

```

Let's now merge that 2 eDNA metabarcoding datasets:

```{r, echo=FALSE, message=FALSE, warning=FALSE}

# 1) Make taxa IDs unique across markers
taxa_names(ps_18s) <- paste0("18S__", taxa_names(ps_18s))
taxa_names(ps_coi) <- paste0("COI__", taxa_names(ps_coi))

# 2) Add a marker column in the tax_table
add_marker <- function(ps, marker) {
  tt <- as(tax_table(ps), "matrix")
  tt <- cbind(tt, marker = marker)
  tax_table(ps) <- tax_table(tt)
  ps
}
ps_18s <- add_marker(ps_18s, "18S")
ps_coi <- add_marker(ps_coi, "COI")

# 3) Ensure tax_table columns match (pad missing cols with NA)
cols_all <- union(colnames(tax_table(ps_18s)), colnames(tax_table(ps_coi)))

pad_tax <- function(ps, cols_all) {
  tt <- as(tax_table(ps), "matrix")
  miss <- setdiff(cols_all, colnames(tt))
  if (length(miss) > 0) {
    tt <- cbind(tt, matrix(NA, nrow = nrow(tt), ncol = length(miss),
                          dimnames = list(rownames(tt), miss)))
  }
  tt <- tt[, cols_all, drop = FALSE]
  tax_table(ps) <- tax_table(tt)
  ps
}
ps_18s <- pad_tax(ps_18s, cols_all)
ps_coi <- pad_tax(ps_coi, cols_all)

# 4) Merge (stacks taxa/features)
ps_edna <- merge_phyloseq(ps_18s, ps_coi)

ps_edna
table(tax_table(ps_edna)[, "marker"])
```
```{r, echo=FALSE, message=FALSE, warning=FALSE}
library(ggplot2)
sample_data(ps_edna)$cpr <- factor(sample_data(ps_edna)$cpr)

ord <- ordinate(ps_edna, method = "PCoA", distance = "bray")

plot_ordination(ps_edna, ord, color = "cpr") +
  geom_point(size = 3) +
  stat_ellipse(aes(group = cpr),
               type = "norm",
               linetype = "dashed",
               size = 1) +
  scale_color_manual(values = c("#1B9E77", "#D95F02", "#7570B3", "#E7298A")) +
  ggtitle("Ordination â€“ RoCSI eDNA") +
  theme_minimal()
```
### For poster
```{r, echo=FALSE, message=FALSE, warning=FALSE, fig.width=10, fig.height=8}

sample_data(ps_edna)$cpr <- factor(sample_data(ps_edna)$cpr)

p <- plot_ordination(ps_edna, ord, color = "cpr") +
  geom_point(size = 6, alpha = 0.9) +
  stat_ellipse(
    aes(group = cpr),
    type = "norm",
    linetype = "solid",
    linewidth = 1.4
  ) +
  scale_color_manual(
    values = c("#1B9E77", "#D95F02", "#7570B3", "#E7298A"),
    name = "Transect"
  ) +
  labs(
    title = "RoCSI eDNA ordination",
    subtitle = "Points = samples; ellipses = 95% normal confidence"
  ) +
  theme_minimal(base_size = 22) +
  theme(
    # Make it â€œposter boldâ€
    plot.title = element_text(size = 34, face = "bold", hjust = 0),
    plot.subtitle = element_text(size = 20, hjust = 0),

    axis.title = element_text(size = 28, face = "bold"),
    axis.text  = element_text(size = 22),

    legend.title = element_text(size = 26, face = "bold"),
    legend.text  = element_text(size = 22),

    # Put legend where it won't cover data (adjust as needed)
    legend.position = "right",

    # Increase spacing / clarity
    panel.grid.major = element_line(linewidth = 0.5),
    panel.grid.minor = element_blank(),

    # Make it print-friendly
    axis.line = element_line(linewidth = 1, colour = "black"),
    panel.background = element_rect(fill = "white", colour = NA),
    plot.background  = element_rect(fill = "white", colour = NA)
  ) +
  guides(color = guide_legend(override.aes = list(size = 8, alpha = 1)))

p
```


### compare presence/absence in eDNA vs CPR

```{r, echo=FALSE, message=FALSE, warning=FALSE}
pa_transform <- function(ps) {
  ps_pa <- ps
  otu_table(ps_pa) <- otu_table((otu_table(ps) > 0) * 1, taxa_are_rows(ps))
  ps_pa
}

ps_edna_pa <- pa_transform(ps_edna)
ps_cpr_pa  <- pa_transform(ps_cpr)

# 2 get taxa present at a given taxonomic rank

get_taxa_at_rank <- function(ps, rank) {
  tt <- as.data.frame(tax_table(ps))
  
  # taxa present at least once
  present_taxa <- taxa_names(ps)[taxa_sums(ps) > 0]
  
  # extract taxonomic labels
  taxa <- tt[present_taxa, rank]
  
  taxa <- taxa[!is.na(taxa) & taxa != ""]
  unique(as.character(taxa))
}

# 3 Compare eDNA vs CPR across taxonomic levels
ranks_to_test <- intersect(rank_names(ps_edna), rank_names(ps_cpr))

comparison <- lapply(ranks_to_test, function(rank) {
  edna_taxa <- get_taxa_at_rank(ps_edna_pa, rank)
  cpr_taxa  <- get_taxa_at_rank(ps_cpr_pa,  rank)

  data.frame(
    rank = rank,
    n_edna = length(edna_taxa),
    n_cpr  = length(cpr_taxa),
    n_shared = length(intersect(edna_taxa, cpr_taxa)),
    stringsAsFactors = FALSE
  )
})

taxa_overlap_summary <- do.call(rbind, comparison)

taxa_overlap_summary$perc_shared_edna <- with(
  taxa_overlap_summary,
  100 * n_shared / n_edna
)

taxa_overlap_summary$perc_shared_cpr <- with(
  taxa_overlap_summary,
  100 * n_shared / n_cpr
)

# optional: round for nicer tables
taxa_overlap_summary$perc_shared_edna <- round(taxa_overlap_summary$perc_shared_edna, 1)
taxa_overlap_summary$perc_shared_cpr  <- round(taxa_overlap_summary$perc_shared_cpr, 1)

knitr::kable(
  taxa_overlap_summary,
  caption = "Taxonomic overlap between eDNA and CPR datasets (presence/absence).",
  digits = 1
) |>
  kableExtra::kable_styling(full_width = FALSE)

```


::: {.callout-note}
eDNA detects far more taxonomic diversity than CPR, but overlap drops rapidly with taxonomic resolution; CPR diversity is largely a subset of eDNA at high ranks, while species-level agreement is essentially zero.
:::

### Quantifying agreement using similarity metrics per rank (Jaccard similarity)

Jaccard similarity was chosen to compare eDNA and CPR datasets because it provides a simple measure of shared taxa using presenceâ€“absence information

```{r, echo=FALSE, message=FALSE, warning=FALSE}
taxa_overlap_summary$jaccard <- with(
  taxa_overlap_summary,
  n_shared / (n_edna + n_cpr - n_shared)
)

rank_order <- c("Kingdom","Phylum","Class","Order","Family","Genus","Species")
taxa_overlap_summary$rank <- factor(taxa_overlap_summary$rank, levels = rank_order)

library(ggplot2)

ggplot(
  subset(taxa_overlap_summary, rank != "Species"),
  aes(x = rank, y = jaccard)
) +
  geom_col(width = 0.7) +
  scale_y_continuous(limits = c(0, 1)) +
  labs(
    x = "Taxonomic rank",
    y = "Jaccard similarity (presence/absence)",
    title = "Jaccard similarity between eDNA and CPR across taxonomic ranks",
    subtitle = "Species level excluded"
  ) +
  theme_minimal(base_size = 12)

```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
present_taxlabels <- function(ps, rank) {
  tt <- as.data.frame(tax_table(ps))
  present_asvs <- taxa_names(ps)[taxa_sums(ps) > 0]
  labs <- tt[present_asvs, rank]

  labs <- as.character(labs)
  labs <- labs[!is.na(labs) & labs != ""]
  sort(unique(labs))
}

ranks_to_test <- intersect(rank_names(ps_edna_pa), rank_names(ps_cpr_pa))

rank_taxa_table <- do.call(
  rbind,
  lapply(ranks_to_test, function(rank) {

    edna_taxa <- present_taxlabels(ps_edna_pa, rank)
    cpr_taxa  <- present_taxlabels(ps_cpr_pa,  rank)
    shared    <- intersect(edna_taxa, cpr_taxa)

    data.frame(
      rank   = rank,
      eDNA   = if (length(edna_taxa) > 0) paste(edna_taxa, collapse = ", ") else NA,
      CPR    = if (length(cpr_taxa)  > 0) paste(cpr_taxa,  collapse = ", ") else NA,
      Shared = if (length(shared)    > 0) paste(shared,    collapse = ", ") else NA,
      stringsAsFactors = FALSE
    )
  })
)

```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
library(gt)

rank_taxa_table |>
  (\(x) x[seq_len(match("Order", x$rank)), ])() |>
  gt(rowname_col = "rank") |>

  # Labels
  cols_label(
    eDNA   = "eDNA taxa",
    CPR    = "CPR taxa",
    Shared = "Shared taxa"
  ) |>

  # Header
  tab_header(
    title = "Rank-by-rank taxonomic composition (presence/absence)",
    subtitle = "Comparison between eDNA and CPR datasets"
  ) |>

  # Improve text handling
  cols_width(
    eDNA   ~ px(350),
    CPR    ~ px(350),
    Shared ~ px(350)
  ) |>

  # Wrap long comma-separated lists
  tab_style(
    style = cell_text(whitespace = "normal"),
    locations = cells_body(everything())
  ) |>

  # Make rank labels stand out
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_stub()
  ) |>

  # Subtle table aesthetics
  opt_all_caps() |>
  tab_options(
    table.font.size = "small",
    data_row.padding = px(6),
    heading.title.font.size = 16,
    heading.subtitle.font.size = 12
  )

```

**Table: Notable copepod genera identified from COI (eDNA) and CPR datasets.**

| Genus          | Why Notable                                                | Shelf vs Openâ€‘Ocean Pattern (<10Â° vs >10Â° longitude) | Evidence Source (COI / CPR)       |
|----------------|-------------------------------------------------------------|-------------------------------------------------------|------------------------------------|
| Paracalanus    | Most consistently abundant across longitudes                | Broad, present in both regions                        | COI + CPR                          |
| Clausocalanus  | Strong offshore abundance                                   | Open ocean (>10Â°)                                     | COI + CPR                          |
| Nannocalanus   | Prominent peaks in offshore COI samples                     | Open ocean (>10Â°)                                     | COI + CPR                          |
| Centropages    | Clear blocks near shelf samples                             | Shelf (<10Â°)                                          | COI + CPR                          |
| Acartia        | Coastalâ€‘type genus, repeating in shelf regions              | Shelf (<10Â°)                                          | COI + CPR                          |
| Calanus        | Dominant in CPR at several shelf/slope stations             | Shelfâ€“slope                                           | CPR only (not in COI topâ€‘10)       |
| Temora         | Distinct CPR occurrences in shelf waters                    | Shelf (<10Â°)                                          | CPR                                |
| Metridia       | Offshore oceanic signature in CPR                           | Open ocean (>10Â°)                                     | CPR                                |
| Oithona        | High relative abundance in COI, minimal CPR representation  | Broad, more offshore in COI                           | COI                                |
| Oncaea         | COIâ€‘specific peaks in offshore waters                       | Open ocean (>10Â°)                                     | COI                                |
``

::: {.callout-note}
### ðŸ’¬ Discussion
- Agreement across methods: Paracalanus, Clausocalanus, Nannocalanus, Centropages show consistent patterns in both plots (first four rows), giving confidence they are genuinely abundant and/or habitatâ€‘associated as indicated.
_ CPRâ€‘leaning taxa: Calanus, Temora, Metridia are clearly visible in CPR but not in the COI topâ€‘10 figureâ€”likely reflecting net/ID strengths for these morphologically distinctive, larger calanoids.
_ eDNAâ€‘leaning taxa: Oithona, Oncaea appear strongly in COI but are minimal in CPRâ€”consistent with CPR underâ€‘capturing small/fragile forms and/or taxonomic resolution limits.

:::

### Combined figures

#### zooplankton

```{r, echo=FALSE, message=FALSE, warning=FALSE}
# ---- genera to plot ----
genera10 <- c(
  "Paracalanus","Clausocalanus","Nannocalanus","Centropages","Acartia",
  "Calanus","Temora","Metridia","Oithona","Oncaea"
)

# ---- palette + named colours for the 10 genera ----
my_colors <- c("#FF6666", "#8DD3C7", "#377EB8", "#4DAF4A",
               "#984EA3", "#A6D854", "#FFFF33", "#FF7F00",
               "#F781BF", "#999999")

genus_cols <- setNames(my_colors[1:length(genera10)], genera10)

# ---- helper: phyloseq -> long df with longitude + Genus + PA ----
ps_to_long_df <- function(ps_obj, approach_name, genera_keep, lon_var = NULL, tax_rank = "Genus") {
  stopifnot(inherits(ps_obj, "phyloseq"))

  otu <- as(otu_table(ps_obj), "matrix")
  if (!taxa_are_rows(ps_obj)) otu <- t(otu)
  otu <- (otu > 0) * 1

  tax <- as(tax_table(ps_obj), "matrix") %>% as.data.frame(check.names = FALSE)
  tax$.taxa_id <- rownames(tax)

  sam <- as(sample_data(ps_obj), "data.frame") %>%
    rownames_to_column("SampleID")
  names(sam) <- trimws(names(sam))

  if (is.null(lon_var)) {
    lon_candidates <- names(sam)[grepl("^lon(gitude)?$", tolower(names(sam)))]
    if (length(lon_candidates) == 0) lon_candidates <- names(sam)[grepl("lon|long", tolower(names(sam)))]
    if (length(lon_candidates) == 0) {
      stop(
        "Could not find a longitude column in sample_data(ps_obj).\n",
        "Available columns:\n  ", paste(names(sam), collapse = ", ")
      )
    }
    lon_var <- lon_candidates[1]
  } else {
    if (!lon_var %in% names(sam)) {
      stop(sprintf(
        "Longitude column '%s' not found. Available columns:\n  %s",
        lon_var, paste(names(sam), collapse = ", ")
      ))
    }
  }

  if (!tax_rank %in% names(tax)) {
    stop(sprintf("Tax table column '%s' not found. Available tax ranks:\n  %s",
                 tax_rank, paste(names(tax), collapse = ", ")))
  }

  otu_long <- as.data.frame(otu) %>%
    rownames_to_column(".taxa_id") %>%
    pivot_longer(cols = -".taxa_id", names_to = "SampleID", values_to = "pa")

  otu_long %>%
    left_join(tax, by = ".taxa_id") %>%
    left_join(sam, by = "SampleID") %>%
    mutate(
      Genus = as.character(.data[[tax_rank]]),
      approach = approach_name,
      longitude = as.numeric(.data[[lon_var]])
    ) %>%
    filter(!is.na(Genus), Genus %in% genera_keep) %>%
    select(approach, SampleID, longitude, Genus, pa)
}

# ---- transect binning settings ----
lon_min <- -16.149
lon_max <- -1.246
n_bins  <- 10
lon_breaks <- seq(lon_min, lon_max, length.out = n_bins + 1)

# ---- build binned presence/absence by genus (any detection in bin = present) ----
df_binned <- bind_rows(
  ps_to_long_df(ps_cpr_pa,  "CPR",  genera10, lon_var = NULL, tax_rank = "Genus"),
  ps_to_long_df(ps_edna_pa, "eDNA", genera10, lon_var = NULL, tax_rank = "Genus")
) %>%
  filter(!is.na(longitude), longitude >= lon_min, longitude <= lon_max) %>%
  mutate(lon_bin = cut(longitude, breaks = lon_breaks, include.lowest = TRUE, right = TRUE)) %>%
  group_by(approach, lon_bin, Genus) %>%
  summarise(pa = as.integer(any(pa == 1)), .groups = "drop") %>%
  mutate(
    approach = factor(approach, levels = c("CPR", "eDNA"))
  )

# ---- rank genera by prevalence (most present across bins+approaches = top) ----
genus_rank <- df_binned %>%
  group_by(Genus) %>%
  summarise(prevalence = sum(pa == 1, na.rm = TRUE), .groups = "drop") %>%
  arrange(desc(prevalence), Genus)

genus_levels <- genus_rank$Genus

# apply ordering + fill mapping
df_binned <- df_binned %>%
  mutate(
    Genus = factor(Genus, levels = genus_levels),
    fill_genus = ifelse(pa == 1, as.character(Genus), NA)
  )

# reorder colours to match ranked genera
genus_cols_ranked <- genus_cols[genus_levels]

# ---- x-axis labels: bin midpoints ----
bin_mids <- (lon_breaks[-1] + lon_breaks[-length(lon_breaks)]) / 2
mid_labels <- sprintf("%.2f", bin_mids)
names(mid_labels) <- levels(df_binned$lon_bin)

# ---- plot (match phytoplankton style) ----
p <- ggplot(df_binned, aes(x = lon_bin, y = Genus, fill = fill_genus)) +
  geom_tile(width = 0.95, height = 0.9, colour = "grey80") +
  facet_wrap(~ approach, ncol = 1) +
  scale_fill_manual(
    values = genus_cols_ranked,
    na.value = "white",
    breaks = genus_levels,
    limits = genus_levels,
    drop = FALSE,
    name = "Genus"
  ) +
  scale_x_discrete(labels = mid_labels) +
  scale_y_discrete(limits = rev(genus_levels)) +  # most prevalent at TOP
  labs(x = "Longitude section (bin midpoint)", y = NULL) +
  theme_minimal(base_size = 12) +
  theme(
    panel.grid = element_blank(),
    strip.text = element_text(face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.text.y  = element_blank(),
    axis.ticks.y = element_blank(),
    axis.title.y = element_blank()
  )

print(p)
```
#### Phytoplankton

```{r, echo=FALSE, message=FALSE, warning=FALSE}

# ---- genera to plot ----
families9 <- c(
  "Rhizosoleniaceae",
  "Chaetoceraceae",
  "Ceratiaceae",
  "Coccolithaceae",
  "Dictyochaceae",
  "Leptocylindraceae",
  "Noelaerhabdaceae",
  "Rhabdosphaeraceae",
  "Prorocentraceae"
)

# ---- your palette + named colours for the 10 genera ----
my_colors <- c("#66C2A5", "#FC8D62", "#8DA0CB", "#E78AC3", "#FFD92F",
               "#E5C494", "#B3B3B3", "#A65628","#FFFFB3", "#BEBADA",
               "#FB8072", "#80B1D3", "#FDB462")

fam_cols <- setNames(my_colors[1:length(families9)], families9)

# ---- helper: phyloseq -> long df with longitude + Family + PA ----
ps_to_long_df <- function(ps_obj, approach_name, families_keep, lon_var = NULL, tax_rank = "Family") {
  stopifnot(inherits(ps_obj, "phyloseq"))

  # OTU (taxa x samples) presence/absence
  otu <- as(otu_table(ps_obj), "matrix")
  if (!taxa_are_rows(ps_obj)) otu <- t(otu)
  otu <- (otu > 0) * 1

  # taxonomy
  tax <- as(tax_table(ps_obj), "matrix") %>% as.data.frame(check.names = FALSE)
  tax$.taxa_id <- rownames(tax)

  # sample data
  sam <- as(sample_data(ps_obj), "data.frame") %>%
    rownames_to_column("SampleID")
  names(sam) <- trimws(names(sam))

  # detect longitude column if not provided
  if (is.null(lon_var)) {
    lon_candidates <- names(sam)[grepl("^lon(gitude)?$", tolower(names(sam)))]
    if (length(lon_candidates) == 0) lon_candidates <- names(sam)[grepl("lon|long", tolower(names(sam)))]
    if (length(lon_candidates) == 0) {
      stop(
        "Could not find a longitude column in sample_data(ps_obj).\n",
        "Available columns:\n  ", paste(names(sam), collapse = ", ")
      )
    }
    lon_var <- lon_candidates[1]
  } else {
    if (!lon_var %in% names(sam)) {
      stop(sprintf(
        "Longitude column '%s' not found. Available columns:\n  %s",
        lon_var, paste(names(sam), collapse = ", ")
      ))
    }
  }

  if (!tax_rank %in% names(tax)) {
    stop(sprintf("Tax table column '%s' not found. Available tax ranks:\n  %s",
                 tax_rank, paste(names(tax), collapse = ", ")))
  }

  otu_long <- as.data.frame(otu) %>%
    rownames_to_column(".taxa_id") %>%
    pivot_longer(cols = -".taxa_id", names_to = "SampleID", values_to = "pa")

  otu_long %>%
    left_join(tax, by = ".taxa_id") %>%
    left_join(sam, by = "SampleID") %>%
    mutate(
      Family = as.character(.data[[tax_rank]]),
      approach = approach_name,
      longitude = as.numeric(.data[[lon_var]])
    ) %>%
    filter(!is.na(Family), Family %in% families_keep) %>%
    select(approach, SampleID, longitude, Family, pa)
}

# ---- transect binning settings ----
lon_min <- -16.149
lon_max <- -1.246
n_bins  <- 10
lon_breaks <- seq(lon_min, lon_max, length.out = n_bins + 1)

# ---- build binned presence/absence by family (any detection in bin = present) ----
# ---- build binned presence/absence by family (any detection in bin = present) ----
df_binned <- bind_rows(
  ps_to_long_df(ps_cpr_pa,  "CPR",  families9, lon_var = NULL, tax_rank = "Family"),
  ps_to_long_df(ps_edna_pa, "eDNA", families9, lon_var = NULL, tax_rank = "Family")
) %>%
  filter(!is.na(longitude), longitude >= lon_min, longitude <= lon_max) %>%
  mutate(lon_bin = cut(longitude, breaks = lon_breaks, include.lowest = TRUE, right = TRUE)) %>%
  group_by(approach, lon_bin, Family) %>%
  summarise(pa = as.integer(any(pa == 1)), .groups = "drop") %>%
  mutate(
    approach = factor(approach, levels = c("CPR", "eDNA"))
  )

# ---- rank families (top = most prevalent across bins and approaches) ----
fam_rank <- df_binned %>%
  group_by(Family) %>%
  summarise(
    # prevalence across ALL bins/approaches
    prevalence = sum(pa == 1, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  arrange(desc(prevalence), Family)

fam_levels <- fam_rank$Family  # most prevalent first

# ---- apply ordering + fill mapping ----
df_binned <- df_binned %>%
  mutate(
    Family = factor(Family, levels = fam_levels),  # rows/legend order control
    fill_family = ifelse(pa == 1, as.character(Family), NA)
  )

# reorder colours to match the ranked families
fam_cols_ranked <- fam_cols[fam_levels]

# ---- x-axis labels: bin midpoints ----
bin_mids <- (lon_breaks[-1] + lon_breaks[-length(lon_breaks)]) / 2
mid_labels <- sprintf("%.2f", bin_mids)
names(mid_labels) <- levels(df_binned$lon_bin)

# ---- plot ----
p <- ggplot(df_binned, aes(x = lon_bin, y = Family, fill = fill_family)) +
  geom_tile(width = 0.95, height = 0.9, colour = "grey80") +
  facet_wrap(~ approach, ncol = 1) +
  scale_fill_manual(
    values = fam_cols_ranked,
    na.value = "white",
    breaks = fam_levels,
    limits = fam_levels,
    drop = FALSE,
    name = "Family"
  ) +
  scale_x_discrete(labels = mid_labels) +
  scale_y_discrete(limits = rev(fam_levels)) +
  labs(x = "Longitude section (bin midpoint)", y = NULL) +
  theme_minimal(base_size = 12) +
  theme(
    panel.grid = element_blank(),
    strip.text = element_text(face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1),

    # ðŸ”¹ Remove y-axis completely
    axis.text.y  = element_blank(),
    axis.ticks.y = element_blank(),
    axis.title.y = element_blank()
  )

print(p)
```

### Next

- Presence/absence by region: Does agreement improve in high-biomass / high-diversity regions? --> Heatmap for the 10 copepods?
- comparing ecological groups: Zooplankton/phytoplankton only
- Sensitivity analysis: e.g. taxa present in â‰¥2 samples


**A spectrum of biodiversity resolution**

These methods can be viewed as sampling different dimensions of diversity along a continuum of biological detail:

CPR (morphological counts) primarily captures â†’ large-bodied, abundant, and morphologically distinctive taxa â†’ reflects biomass-dominant and ecologically conspicuous organisms â†’ integrates over time and space due to net sampling and tow length

eDNA metabarcoding (18S, COI) captures â†’ small, fragile, rare, cryptic, or early life stages â†’ reflects presence and relative diversity, not biomass â†’ is sensitive to extracellular DNA, transport, and detection limits

Because these approaches target different components of the community, direct one-to-one taxonomic comparisons are not always meaningful.

![Resolution pyramid - CPR vs RoCSI eDNA](CPR%20vs%20eDNA%20biological%20resolution%20comparison.png){width="80%"}

![Horizontal gradient of ecological resolution](ChatGPT%20Image%20Jan%206,%202026,%2003_15_35%20PM.png)

